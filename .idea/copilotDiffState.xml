<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/data/dao/SolicitudDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/data/dao/SolicitudDao.kt" />
              <option name="originalContent" value="package appserviciotecnico.model.data.dao&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Delete&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import appserviciotecnico.model.data.entities.SolicitudEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;// DAO para gestionar solicitudes/citas de servicio&#10;@Dao&#10;interface SolicitudDao {&#10;&#10;    @Insert(onConflict = OnConflictStrategy.Companion.REPLACE)&#10;    suspend fun insertSolicitud(solicitud: SolicitudEntity): Long&#10;&#10;    @Query(&quot;SELECT * FROM solicitud_cita ORDER BY fechaAgendada DESC&quot;)&#10;    fun getSolicitudes(): Flow&lt;List&lt;SolicitudEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM solicitud_cita WHERE estado = :estado ORDER BY fechaAgendada DESC&quot;)&#10;    fun getSolicitudesByEstado(estado: String): Flow&lt;List&lt;SolicitudEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM solicitud_cita WHERE id = :id&quot;)&#10;    suspend fun getSolicitudById(id: Long): SolicitudEntity?&#10;&#10;    @Update&#10;    suspend fun updateSolicitud(solicitud: SolicitudEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteSolicitud(solicitud: SolicitudEntity)&#10;&#10;    @Query(&quot;DELETE FROM solicitud_cita&quot;)&#10;    suspend fun deleteAll()&#10;}" />
              <option name="updatedContent" value="package appserviciotecnico.model.data.dao&#13;&#10;&#13;&#10;import androidx.room.Dao&#13;&#10;import androidx.room.Delete&#13;&#10;import androidx.room.Insert&#13;&#10;import androidx.room.OnConflictStrategy&#13;&#10;import androidx.room.Query&#13;&#10;import androidx.room.Update&#13;&#10;import appserviciotecnico.model.data.entities.SolicitudEntity&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;&#13;&#10;// DAO para gestionar solicitudes/citas de servicio&#13;&#10;@Dao&#13;&#10;interface SolicitudDao {&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.Companion.REPLACE)&#13;&#10;    suspend fun insertSolicitud(solicitud: SolicitudEntity): Long&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM solicitud_cita ORDER BY fechaAgendada DESC&quot;)&#13;&#10;    fun getSolicitudes(): Flow&lt;List&lt;SolicitudEntity&gt;&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM solicitud_cita WHERE estado = :estado ORDER BY fechaAgendada DESC&quot;)&#13;&#10;    fun getSolicitudesByEstado(estado: String): Flow&lt;List&lt;SolicitudEntity&gt;&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM solicitud_cita WHERE id = :id&quot;)&#13;&#10;    suspend fun getSolicitudById(id: Long): SolicitudEntity?&#13;&#10;&#13;&#10;    @Update&#13;&#10;    suspend fun updateSolicitud(solicitud: SolicitudEntity)&#13;&#10;&#13;&#10;    @Delete&#10;    suspend fun deleteSolicitud(solicitud: SolicitudEntity)&#10;&#10;    @Query(&quot;DELETE FROM solicitud_cita WHERE id = :id&quot;)&#10;    suspend fun deleteSolicitudById(id: Long)&#10;&#10;    @Query(&quot;DELETE FROM solicitud_cita&quot;)&#10;    suspend fun deleteAll()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/data/repository/SolicitudRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/data/repository/SolicitudRepository.kt" />
              <option name="originalContent" value="package appserviciotecnico.model.data.repository&#10;&#10;import appserviciotecnico.model.data.dao.SolicitudDao&#10;import appserviciotecnico.model.data.entities.SolicitudEntity&#10;&#10;// Repositorio para gestionar solicitudes/citas de servicio&#10;class SolicitudRepository(&#10;    private val dao: SolicitudDao&#10;) {&#10;&#10;    fun obtenerSolicitudes() = dao.getSolicitudes()&#10;&#10;    fun obtenerSolicitudesPorEstado(estado: String) = dao.getSolicitudesByEstado(estado)&#10;&#10;    suspend fun obtenerSolicitudPorId(id: Long): SolicitudEntity? {&#10;        return dao.getSolicitudById(id)&#10;    }&#10;&#10;    suspend fun guardarSolicitud(entity: SolicitudEntity): Long {&#10;        return dao.insertSolicitud(entity)&#10;    }&#10;&#10;    suspend fun actualizarSolicitud(entity: SolicitudEntity) {&#10;        dao.updateSolicitud(entity)&#10;    }&#10;&#10;    suspend fun eliminarSolicitud(entity: SolicitudEntity) {&#10;        dao.deleteSolicitud(entity)&#10;    }&#10;&#10;    suspend fun limpiar() = dao.deleteAll()&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package appserviciotecnico.model.data.repository&#13;&#10;&#13;&#10;import appserviciotecnico.model.data.dao.SolicitudDao&#13;&#10;import appserviciotecnico.model.data.entities.SolicitudEntity&#13;&#10;&#13;&#10;// Repositorio para gestionar solicitudes/citas de servicio&#13;&#10;class SolicitudRepository(&#13;&#10;    private val dao: SolicitudDao&#13;&#10;) {&#13;&#10;&#13;&#10;    fun obtenerSolicitudes() = dao.getSolicitudes()&#13;&#10;&#13;&#10;    fun obtenerSolicitudesPorEstado(estado: String) = dao.getSolicitudesByEstado(estado)&#13;&#10;&#13;&#10;    suspend fun obtenerSolicitudPorId(id: Long): SolicitudEntity? {&#13;&#10;        return dao.getSolicitudById(id)&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun guardarSolicitud(entity: SolicitudEntity): Long {&#13;&#10;        return dao.insertSolicitud(entity)&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun actualizarSolicitud(entity: SolicitudEntity) {&#13;&#10;        dao.updateSolicitud(entity)&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun eliminarSolicitud(entity: SolicitudEntity) {&#10;        dao.deleteSolicitud(entity)&#10;    }&#10;&#10;    suspend fun eliminarSolicitudPorId(id: Long) {&#10;        dao.deleteSolicitudById(id)&#10;    }&#10;&#10;    suspend fun limpiar() = dao.deleteAll()&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/EliminarSolicitudUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/EliminarSolicitudUseCase.kt" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain.usecases&#10;&#10;import appserviciotecnico.model.data.repository.SolicitudRepository&#10;&#10;/**&#10; * Caso de uso: Eliminar solicitud de servicio&#10; * Encapsula la lógica de negocio para eliminar una solicitud&#10; */&#10;class EliminarSolicitudUseCase(&#10;    private val repository: SolicitudRepository&#10;) {&#10;&#10;    suspend fun execute(solicitudId: Long): Result&lt;Unit&gt; {&#10;        return try {&#10;            if (solicitudId &lt;= 0) {&#10;                return Result.failure(Exception(&quot;ID de solicitud inválido&quot;))&#10;            }&#10;&#10;            repository.eliminarSolicitudPorId(solicitudId)&#10;            Result.success(Unit)&#10;&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/GuardarCotizacionUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/GuardarCotizacionUseCase.kt" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain.usecases&#10;&#10;import appserviciotecnico.model.data.entities.FormularioServicioEntity&#10;import appserviciotecnico.model.data.repository.FormularioServicioRepository&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * Caso de uso: Guardar cotización de servicio técnico&#10; * Encapsula la lógica de negocio para crear una solicitud de cotización&#10; */&#10;class GuardarCotizacionUseCase(&#10;    private val repository: FormularioServicioRepository&#10;) {&#10;&#10;    suspend fun execute(&#10;        nombreCliente: String,&#10;        correoCliente: String,&#10;        telefonoCliente: String,&#10;        tipoConsola: String,&#10;        modeloConsola: String,&#10;        descripcionProblema: String&#10;    ): Result&lt;Long&gt; {&#10;        return try {&#10;            // Validar datos básicos&#10;            if (nombreCliente.isBlank()) {&#10;                return Result.failure(Exception(&quot;El nombre del cliente es requerido&quot;))&#10;            }&#10;&#10;            if (correoCliente.isBlank() || !correoCliente.contains(&quot;@&quot;)) {&#10;                return Result.failure(Exception(&quot;El correo electrónico es inválido&quot;))&#10;            }&#10;&#10;            // Crear la entidad con la lógica de negocio&#10;            val entity = FormularioServicioEntity(&#10;                nombreCliente = nombreCliente,&#10;                correoCliente = correoCliente,&#10;                telefonoCliente = telefonoCliente,&#10;                tipoConsola = tipoConsola,&#10;                modeloConsola = modeloConsola,&#10;                descripcionProblema = descripcionProblema,&#10;                estadoSolicitud = &quot;Pendiente&quot;,&#10;                fechaSolicitud = SimpleDateFormat(&#10;                    &quot;dd 'de' MMMM 'de' yyyy HH:mm&quot;,&#10;                    Locale.forLanguageTag(&quot;es-ES&quot;)&#10;                ).format(Date())&#10;            )&#10;&#10;            // Guardar en el repositorio&#10;            val id = repository.guardarFormulario(entity)&#10;            Result.success(id)&#10;&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/factories/EstadoSolicitudesViewModelFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/factories/EstadoSolicitudesViewModelFactory.kt" />
              <option name="originalContent" value="package appserviciotecnico.viewmodel.factories&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import appserviciotecnico.model.data.config.AppDatabase&#10;import appserviciotecnico.model.data.repository.SolicitudRepository&#10;import appserviciotecnico.viewmodel.viewmodels.EstadoSolicitudesViewModel&#10;&#10;//  Factory para crear EstadoSolicitudesViewModel con Repository&#10;class EstadoSolicitudesViewModelFactory(&#10;    private val application: Application&#10;) : ViewModelProvider.Factory {&#10;&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(EstadoSolicitudesViewModel::class.java)) {&#10;            val database = AppDatabase.Companion.getDatabase(application)&#10;            val repository = SolicitudRepository(database.solicitudDao())&#10;            return EstadoSolicitudesViewModel(repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package appserviciotecnico.viewmodel.factories&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import appserviciotecnico.model.data.config.AppDatabase&#10;import appserviciotecnico.model.data.repository.SolicitudRepository&#10;import appserviciotecnico.model.domain.usecases.ObtenerSolicitudesUseCase&#10;import appserviciotecnico.viewmodel.viewmodels.EstadoSolicitudesViewModel&#10;&#10;// Factory para crear EstadoSolicitudesViewModel con UseCase&#10;class EstadoSolicitudesViewModelFactory(&#10;    private val application: Application&#10;) : ViewModelProvider.Factory {&#10;&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(EstadoSolicitudesViewModel::class.java)) {&#10;            val database = AppDatabase.getDatabase(application)&#10;            val repository = SolicitudRepository(database.solicitudDao())&#10;            val obtenerSolicitudesUseCase = ObtenerSolicitudesUseCase(repository)&#10;            return EstadoSolicitudesViewModel(obtenerSolicitudesUseCase, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/factories/FormularioServicioViewModelFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/factories/FormularioServicioViewModelFactory.kt" />
              <option name="originalContent" value="package appserviciotecnico.viewmodel.factories&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import appserviciotecnico.model.data.config.AppDatabase&#10;import appserviciotecnico.model.data.repository.FormularioServicioRepository&#10;import appserviciotecnico.viewmodel.viewmodels.FormularioServicioViewModel&#10;&#10;//  Factory para crear FormularioServicioViewModel con Repository&#10;class FormularioServicioViewModelFactory(&#10;    private val application: Application&#10;) : ViewModelProvider.Factory {&#10;&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(FormularioServicioViewModel::class.java)) {&#10;            val database = AppDatabase.Companion.getDatabase(application)&#10;            val repository = FormularioServicioRepository(database.formularioServicioDao())&#10;            return FormularioServicioViewModel(repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package appserviciotecnico.viewmodel.factories&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import appserviciotecnico.model.data.config.AppDatabase&#10;import appserviciotecnico.model.data.repository.FormularioServicioRepository&#10;import appserviciotecnico.model.domain.usecases.GuardarCotizacionUseCase&#10;import appserviciotecnico.viewmodel.viewmodels.FormularioServicioViewModel&#10;&#10;// Factory para crear FormularioServicioViewModel con UseCase&#10;class FormularioServicioViewModelFactory(&#10;    private val application: Application&#10;) : ViewModelProvider.Factory {&#10;&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(FormularioServicioViewModel::class.java)) {&#10;            val database = AppDatabase.getDatabase(application)&#10;            val repository = FormularioServicioRepository(database.formularioServicioDao())&#10;            val guardarCotizacionUseCase = GuardarCotizacionUseCase(repository)&#10;            return FormularioServicioViewModel(guardarCotizacionUseCase) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/viewmodels/EstadoSolicitudesViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/viewmodels/EstadoSolicitudesViewModel.kt" />
              <option name="originalContent" value="package appserviciotecnico.viewmodel.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import appserviciotecnico.model.data.entities.SolicitudEntity&#10;import appserviciotecnico.model.data.repository.SolicitudRepository&#10;import appserviciotecnico.model.domain.models.EstadoSolicitud&#10;import appserviciotecnico.model.domain.models.Solicitud&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.launch&#10;import java.util.Date&#10;&#10;// ViewModel para gestionar estado de solicitudes&#10;class EstadoSolicitudesViewModel(&#10;    private val repository: SolicitudRepository&#10;) : ViewModel() {&#10;&#10;    // Flow que convierte SolicitudEntity a Solicitud para la UI&#10;    val solicitudes: StateFlow&lt;List&lt;Solicitud&gt;&gt; = repository.obtenerSolicitudes()&#10;        .map { entities -&gt;&#10;            entities.mapNotNull { entity -&gt;&#10;                try {&#10;                    Solicitud(&#10;                        id = entity.id.toInt(),&#10;                        servicio = entity.servicio,&#10;                        fechaAgendada = Date(entity.fechaAgendada),&#10;                        estado = when (entity.estado) {&#10;                            &quot;Pendiente&quot; -&gt; EstadoSolicitud.PENDIENTE&#10;                            &quot;En Proceso&quot; -&gt; EstadoSolicitud.EN_PROCESO&#10;                            &quot;Completado&quot; -&gt; EstadoSolicitud.COMPLETADO&#10;                            &quot;Cancelado&quot; -&gt; EstadoSolicitud.CANCELADO&#10;                            else -&gt; EstadoSolicitud.PENDIENTE&#10;                        },&#10;                        clienteNombre = entity.clienteNombre,&#10;                        descripcion = entity.descripcion,&#10;                        horaAgendada = entity.horaAgendada&#10;                    )&#10;                } catch (_: Exception) {&#10;                    // Si hay error mapeando alguna entidad, la ignoramos&#10;                    null&#10;                }&#10;            }&#10;        }&#10;        .stateIn(&#10;            scope = viewModelScope,&#10;            started = SharingStarted.Companion.WhileSubscribed(5000),&#10;            initialValue = emptyList()&#10;        )&#10;&#10;    // ️ Eliminar una solicitud&#10;    fun eliminarSolicitud(solicitud: Solicitud) {&#10;        viewModelScope.launch {&#10;            val entity = SolicitudEntity(&#10;                id = solicitud.id.toLong(),&#10;                servicio = solicitud.servicio,&#10;                fechaAgendada = solicitud.fechaAgendada.time,&#10;                estado = solicitud.estado.texto,&#10;                clienteNombre = solicitud.clienteNombre,&#10;                descripcion = solicitud.descripcion,&#10;                horaAgendada = solicitud.horaAgendada,&#10;                categoriaId = 0  // Valor por defecto si no está disponible&#10;            )&#10;            repository.eliminarSolicitud(entity)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package appserviciotecnico.viewmodel.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import appserviciotecnico.model.data.entities.SolicitudEntity&#10;import appserviciotecnico.model.data.repository.SolicitudRepository&#10;import appserviciotecnico.model.domain.models.Solicitud&#10;import appserviciotecnico.model.domain.usecases.ObtenerSolicitudesUseCase&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.launch&#10;&#10;// ViewModel para gestionar estado de solicitudes&#10;class EstadoSolicitudesViewModel(&#10;    private val obtenerSolicitudesUseCase: ObtenerSolicitudesUseCase,&#10;    private val repository: SolicitudRepository  // Solo para eliminar&#10;) : ViewModel() {&#10;&#10;    // Flow que obtiene las solicitudes usando el UseCase&#10;    val solicitudes: StateFlow&lt;List&lt;Solicitud&gt;&gt; = obtenerSolicitudesUseCase()&#10;        .stateIn(&#10;            scope = viewModelScope,&#10;            started = SharingStarted.WhileSubscribed(5000),&#10;            initialValue = emptyList()&#10;        )&#10;&#10;    // ️ Eliminar una solicitud&#10;    fun eliminarSolicitud(solicitud: Solicitud) {&#10;        viewModelScope.launch {&#10;            val entity = SolicitudEntity(&#10;                id = solicitud.id.toLong(),&#10;                servicio = solicitud.servicio,&#10;                fechaAgendada = solicitud.fechaAgendada.time,&#10;                estado = solicitud.estado.texto,&#10;                clienteNombre = solicitud.clienteNombre,&#10;                descripcion = solicitud.descripcion,&#10;                horaAgendada = solicitud.horaAgendada,&#10;                categoriaId = 0  // Valor por defecto si no está disponible&#10;            )&#10;            repository.eliminarSolicitud(entity)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/viewmodels/FormularioServicioViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/viewmodels/FormularioServicioViewModel.kt" />
              <option name="originalContent" value="package appserviciotecnico.viewmodel.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import appserviciotecnico.model.data.entities.FormularioServicioEntity&#10;import appserviciotecnico.model.data.repository.FormularioServicioRepository&#10;import appserviciotecnico.model.domain.validators.FormularioServicioErrores&#10;import appserviciotecnico.viewmodel.states.FormularioServicioState&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;// ViewModel para gestionar el formulario de servicio técnico PlayStation&#10;class FormularioServicioViewModel(&#10;    private val repository: FormularioServicioRepository&#10;) : ViewModel() {&#10;&#10;    private val _estado = MutableStateFlow(FormularioServicioState())&#10;    val estado: StateFlow&lt;FormularioServicioState&gt; = _estado.asStateFlow()&#10;&#10;    // ✏️ Funciones para actualizar cada campo&#10;    fun onNombreChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                nombreCliente = valor,&#10;                errores = it.errores.copy(nombreCliente = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onCorreoChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                correoCliente = valor,&#10;                errores = it.errores.copy(emailCliente = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onTelefonoChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                telefonoCliente = valor,&#10;                errores = it.errores.copy(telefonoCliente = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onTipoConsolaChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                tipoConsola = valor,&#10;                errores = it.errores.copy(tipoConsola = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onModeloConsolaChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                modeloConsola = valor,&#10;                errores = it.errores.copy(modeloConsola = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onDescripcionChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                descripcionProblema = valor,&#10;                errores = it.errores.copy(descripcionProblema = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    //  Validar y enviar formulario&#10;    fun onEnviarFormulario() {&#10;        val estadoActual = _estado.value&#10;        val errores = validarFormulario(estadoActual)&#10;&#10;        if (errores.hasErrors()) {&#10;            _estado.update { it.copy(errores = errores) }&#10;            return&#10;        }&#10;&#10;        // Guardar en Room Database&#10;        _estado.update {&#10;            it.copy(&#10;                enviando = true,&#10;                errores = FormularioServicioErrores()&#10;            )&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val entity = FormularioServicioEntity(&#10;                    nombreCliente = estadoActual.nombreCliente,&#10;                    correoCliente = estadoActual.correoCliente,&#10;                    telefonoCliente = estadoActual.telefonoCliente,&#10;                    tipoConsola = estadoActual.tipoConsola,&#10;                    modeloConsola = estadoActual.modeloConsola,&#10;                    descripcionProblema = estadoActual.descripcionProblema,&#10;                    estadoSolicitud = &quot;Pendiente&quot;,  // Estado inicial&#10;                    fechaSolicitud = SimpleDateFormat(&#10;                        &quot;dd 'de' MMMM 'de' yyyy HH:mm&quot;,&#10;                        Locale.forLanguageTag(&quot;es-ES&quot;)&#10;                    ).format(&#10;                        Date()&#10;                    )&#10;                )&#10;&#10;                repository.guardarFormulario(entity)&#10;&#10;                _estado.update {&#10;                    it.copy(&#10;                        enviando = false,&#10;                        mensajeExito = &quot;✅ Cotización solicitada exitosamente. Te contactaremos pronto con el presupuesto.&quot;&#10;                    )&#10;                }&#10;&#10;                // Limpiar formulario después de 2 segundos&#10;                delay(2000)&#10;                limpiarFormulario()&#10;&#10;            } catch (e: Exception) {&#10;                _estado.update {&#10;                    it.copy(&#10;                        enviando = false,&#10;                        mensajeExito = &quot;❌ Error al guardar: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    //  Validar todos los campos&#10;    private fun validarFormulario(estado: FormularioServicioState): FormularioServicioErrores {&#10;        return FormularioServicioErrores(&#10;            nombreCliente = if (estado.nombreCliente.isBlank())&#10;                &quot;El nombre es requerido&quot; else null,&#10;&#10;            emailCliente = when {&#10;                estado.correoCliente.isBlank() -&gt; &quot;El correo es requerido&quot;&#10;                !estado.correoCliente.contains(&quot;@&quot;) -&gt; &quot;Correo inválido&quot;&#10;                else -&gt; null&#10;            },&#10;&#10;            telefonoCliente = if (estado.telefonoCliente.isBlank())&#10;                &quot;El teléfono es requerido&quot; else null,&#10;&#10;            tipoConsola = if (estado.tipoConsola.isBlank())&#10;                &quot;Seleccione el tipo de consola&quot; else null,&#10;&#10;            modeloConsola = if (estado.modeloConsola.isBlank())&#10;                &quot;El modelo es requerido&quot; else null,&#10;&#10;            descripcionProblema = if (estado.descripcionProblema.isBlank())&#10;                &quot;Describa el problema&quot; else null&#10;        )&#10;    }&#10;&#10;    //  Limpiar formulario&#10;    private fun limpiarFormulario() {&#10;        _estado.update { FormularioServicioState() }&#10;    }&#10;}" />
              <option name="updatedContent" value="package appserviciotecnico.viewmodel.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import appserviciotecnico.model.domain.usecases.GuardarCotizacionUseCase&#10;import appserviciotecnico.model.domain.validators.FormularioServicioErrores&#10;import appserviciotecnico.viewmodel.states.FormularioServicioState&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;// ViewModel para gestionar el formulario de servicio técnico PlayStation&#10;class FormularioServicioViewModel(&#10;    private val guardarCotizacionUseCase: GuardarCotizacionUseCase&#10;) : ViewModel() {&#10;&#10;    private val _estado = MutableStateFlow(FormularioServicioState())&#10;    val estado: StateFlow&lt;FormularioServicioState&gt; = _estado.asStateFlow()&#10;&#10;    // ✏️ Funciones para actualizar cada campo&#10;    fun onNombreChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                nombreCliente = valor,&#10;                errores = it.errores.copy(nombreCliente = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onCorreoChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                correoCliente = valor,&#10;                errores = it.errores.copy(emailCliente = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onTelefonoChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                telefonoCliente = valor,&#10;                errores = it.errores.copy(telefonoCliente = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onTipoConsolaChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                tipoConsola = valor,&#10;                errores = it.errores.copy(tipoConsola = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onModeloConsolaChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                modeloConsola = valor,&#10;                errores = it.errores.copy(modeloConsola = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun onDescripcionChange(valor: String) {&#10;        _estado.update {&#10;            it.copy(&#10;                descripcionProblema = valor,&#10;                errores = it.errores.copy(descripcionProblema = null)&#10;            )&#10;        }&#10;    }&#10;&#10;    //  Validar y enviar formulario&#10;    fun onEnviarFormulario() {&#10;        val estadoActual = _estado.value&#10;        val errores = validarFormulario(estadoActual)&#10;&#10;        if (errores.hasErrors()) {&#10;            _estado.update { it.copy(errores = errores) }&#10;            return&#10;        }&#10;&#10;        // Guardar usando UseCase&#10;        _estado.update {&#10;            it.copy(&#10;                enviando = true,&#10;                errores = FormularioServicioErrores()&#10;            )&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            val resultado = guardarCotizacionUseCase.execute(&#10;                nombreCliente = estadoActual.nombreCliente,&#10;                correoCliente = estadoActual.correoCliente,&#10;                telefonoCliente = estadoActual.telefonoCliente,&#10;                tipoConsola = estadoActual.tipoConsola,&#10;                modeloConsola = estadoActual.modeloConsola,&#10;                descripcionProblema = estadoActual.descripcionProblema&#10;            )&#10;&#10;            resultado.fold(&#10;                onSuccess = {&#10;                    _estado.update {&#10;                        it.copy(&#10;                            enviando = false,&#10;                            mensajeExito = &quot;✅ Cotización solicitada exitosamente. Te contactaremos pronto con el presupuesto.&quot;&#10;                        )&#10;                    }&#10;&#10;                    // Limpiar formulario después de 2 segundos&#10;                    delay(2000)&#10;                    limpiarFormulario()&#10;                },&#10;                onFailure = { e -&gt;&#10;                    _estado.update {&#10;                        it.copy(&#10;                            enviando = false,&#10;                            mensajeExito = &quot;❌ Error al guardar: ${e.message}&quot;&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    //  Validar todos los campos&#10;    private fun validarFormulario(estado: FormularioServicioState): FormularioServicioErrores {&#10;        return FormularioServicioErrores(&#10;            nombreCliente = if (estado.nombreCliente.isBlank())&#10;                &quot;El nombre es requerido&quot; else null,&#10;&#10;            emailCliente = when {&#10;                estado.correoCliente.isBlank() -&gt; &quot;El correo es requerido&quot;&#10;                !estado.correoCliente.contains(&quot;@&quot;) -&gt; &quot;Correo inválido&quot;&#10;                else -&gt; null&#10;            },&#10;&#10;            telefonoCliente = if (estado.telefonoCliente.isBlank())&#10;                &quot;El teléfono es requerido&quot; else null,&#10;&#10;            tipoConsola = if (estado.tipoConsola.isBlank())&#10;                &quot;Seleccione el tipo de consola&quot; else null,&#10;&#10;            modeloConsola = if (estado.modeloConsola.isBlank())&#10;                &quot;El modelo es requerido&quot; else null,&#10;&#10;            descripcionProblema = if (estado.descripcionProblema.isBlank())&#10;                &quot;Describa el problema&quot; else null&#10;        )&#10;    }&#10;&#10;    //  Limpiar formulario&#10;    private fun limpiarFormulario() {&#10;        _estado.update { FormularioServicioState() }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>