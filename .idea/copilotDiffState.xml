<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/EliminarSolicitudUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/EliminarSolicitudUseCase.kt" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain.usecases&#10;&#10;import appserviciotecnico.model.data.repository.SolicitudRepository&#10;&#10;/**&#10; * Caso de uso: Eliminar solicitud de servicio&#10; * Encapsula la lógica de negocio para eliminar una solicitud&#10; */&#10;class EliminarSolicitudUseCase(&#10;    private val repository: SolicitudRepository&#10;) {&#10;&#10;    suspend fun execute(solicitudId: Long): Result&lt;Unit&gt; {&#10;        return try {&#10;            if (solicitudId &lt;= 0) {&#10;                return Result.failure(Exception(&quot;ID de solicitud inválido&quot;))&#10;            }&#10;&#10;            repository.eliminarSolicitudPorId(solicitudId)&#10;            Result.success(Unit)&#10;&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/api/CotizacionApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/api/CotizacionApi.kt" />
              <option name="updatedContent" value="package appserviciotecnico.network.api&#10;&#10;import appserviciotecnico.network.models.CotizacionDTO&#10;import okhttp3.ResponseBody&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;/**&#10; * API Service: Endpoints del microservicio de Cotizaciones&#10; */&#10;interface CotizacionApi {&#10;&#10;    @GET(&quot;cotizaciones&quot;)&#10;    suspend fun obtenerCotizaciones(): Response&lt;List&lt;CotizacionDTO&gt;&gt;&#10;&#10;    @GET(&quot;cotizaciones/{id}&quot;)&#10;    suspend fun obtenerPorId(@Path(&quot;id&quot;) id: Long): Response&lt;CotizacionDTO&gt;&#10;&#10;    @POST(&quot;cotizaciones&quot;)&#10;    suspend fun crearCotizacion(@Body cotizacion: CotizacionDTO): Response&lt;CotizacionDTO&gt;&#10;&#10;    @PUT(&quot;cotizaciones/{id}&quot;)&#10;    suspend fun actualizarCotizacion(&#10;        @Path(&quot;id&quot;) id: Long,&#10;        @Body cotizacion: CotizacionDTO&#10;    ): Response&lt;CotizacionDTO&gt;&#10;&#10;    @DELETE(&quot;cotizaciones/{id}&quot;)&#10;    suspend fun eliminarCotizacion(@Path(&quot;id&quot;) id: Long): Response&lt;ResponseBody&gt;&#10;&#10;    @GET(&quot;cotizaciones/estado/{estado}&quot;)&#10;    suspend fun obtenerPorEstado(@Path(&quot;estado&quot;) estado: String): Response&lt;List&lt;CotizacionDTO&gt;&gt;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/api/SolicitudApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/api/SolicitudApi.kt" />
              <option name="updatedContent" value="package appserviciotecnico.network.api&#10;&#10;import appserviciotecnico.network.models.SolicitudDTO&#10;import okhttp3.ResponseBody&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;/**&#10; * API Service: Endpoints del microservicio de Solicitudes&#10; * Consume los endpoints REST del backend Spring Boot&#10; */&#10;interface SolicitudApi {&#10;&#10;    /**&#10;     * GET /api/solicitudes&#10;     * Obtener todas las solicitudes&#10;     */&#10;    @GET(&quot;solicitudes&quot;)&#10;    suspend fun obtenerSolicitudes(): Response&lt;List&lt;SolicitudDTO&gt;&gt;&#10;&#10;    /**&#10;     * GET /api/solicitudes/{id}&#10;     * Obtener una solicitud por ID&#10;     */&#10;    @GET(&quot;solicitudes/{id}&quot;)&#10;    suspend fun obtenerPorId(@Path(&quot;id&quot;) id: Long): Response&lt;SolicitudDTO&gt;&#10;&#10;    /**&#10;     * POST /api/solicitudes&#10;     * Crear nueva solicitud&#10;     */&#10;    @POST(&quot;solicitudes&quot;)&#10;    suspend fun crearSolicitud(@Body solicitud: SolicitudDTO): Response&lt;SolicitudDTO&gt;&#10;&#10;    /**&#10;     * PUT /api/solicitudes/{id}&#10;     * Actualizar solicitud existente&#10;     */&#10;    @PUT(&quot;solicitudes/{id}&quot;)&#10;    suspend fun actualizarSolicitud(&#10;        @Path(&quot;id&quot;) id: Long,&#10;        @Body solicitud: SolicitudDTO&#10;    ): Response&lt;SolicitudDTO&gt;&#10;&#10;    /**&#10;     * DELETE /api/solicitudes/{id}&#10;     * Eliminar solicitud&#10;     */&#10;    @DELETE(&quot;solicitudes/{id}&quot;)&#10;    suspend fun eliminarSolicitud(@Path(&quot;id&quot;) id: Long): Response&lt;ResponseBody&gt;&#10;&#10;    /**&#10;     * GET /api/solicitudes/estado/{estado}&#10;     * Obtener solicitudes por estado&#10;     */&#10;    @GET(&quot;solicitudes/estado/{estado}&quot;)&#10;    suspend fun obtenerPorEstado(@Path(&quot;estado&quot;) estado: String): Response&lt;List&lt;SolicitudDTO&gt;&gt;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/models/CotizacionDTO.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/models/CotizacionDTO.kt" />
              <option name="updatedContent" value="package appserviciotecnico.network.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;/**&#10; * DTO: Cotización de servicio técnico del backend&#10; */&#10;data class CotizacionDTO(&#10;    @SerializedName(&quot;id&quot;)&#10;    val id: Long? = null,&#10;&#10;    @SerializedName(&quot;nombreCliente&quot;)&#10;    val nombreCliente: String,&#10;&#10;    @SerializedName(&quot;correoCliente&quot;)&#10;    val correoCliente: String,&#10;&#10;    @SerializedName(&quot;telefonoCliente&quot;)&#10;    val telefonoCliente: String,&#10;&#10;    @SerializedName(&quot;tipoConsola&quot;)&#10;    val tipoConsola: String,&#10;&#10;    @SerializedName(&quot;modeloConsola&quot;)&#10;    val modeloConsola: String,&#10;&#10;    @SerializedName(&quot;descripcionProblema&quot;)&#10;    val descripcionProblema: String,&#10;&#10;    @SerializedName(&quot;estadoSolicitud&quot;)&#10;    val estadoSolicitud: String = &quot;PENDIENTE&quot;,&#10;&#10;    @SerializedName(&quot;fechaSolicitud&quot;)&#10;    val fechaSolicitud: String,&#10;&#10;    @SerializedName(&quot;motivoEdicion&quot;)&#10;    val motivoEdicion: String? = null,&#10;&#10;    @SerializedName(&quot;fechaReagendada&quot;)&#10;    val fechaReagendada: String? = null,&#10;&#10;    @SerializedName(&quot;fechaCreacion&quot;)&#10;    val fechaCreacion: String? = null&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/models/SolicitudDTO.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/models/SolicitudDTO.kt" />
              <option name="updatedContent" value="package appserviciotecnico.network.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;/**&#10; * DTO: Solicitud de servicio técnico del backend&#10; * Representa la respuesta JSON del microservicio Spring Boot&#10; */&#10;data class SolicitudDTO(&#10;    @SerializedName(&quot;id&quot;)&#10;    val id: Long? = null,&#10;&#10;    @SerializedName(&quot;servicio&quot;)&#10;    val servicio: String,&#10;&#10;    @SerializedName(&quot;fechaAgendada&quot;)&#10;    val fechaAgendada: String,&#10;&#10;    @SerializedName(&quot;horaAgendada&quot;)&#10;    val horaAgendada: String,&#10;&#10;    @SerializedName(&quot;estado&quot;)&#10;    val estado: String = &quot;PENDIENTE&quot;,&#10;&#10;    @SerializedName(&quot;clienteNombre&quot;)&#10;    val clienteNombre: String,&#10;&#10;    @SerializedName(&quot;descripcion&quot;)&#10;    val descripcion: String,&#10;&#10;    @SerializedName(&quot;categoriaId&quot;)&#10;    val categoriaId: Int,&#10;&#10;    @SerializedName(&quot;fechaCreacion&quot;)&#10;    val fechaCreacion: String? = null&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/repository/SolicitudRemoteRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/repository/SolicitudRemoteRepository.kt" />
              <option name="updatedContent" value="package appserviciotecnico.network.repository&#10;&#10;import android.util.Log&#10;import appserviciotecnico.network.config.RetrofitClient&#10;import appserviciotecnico.network.models.SolicitudDTO&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;/**&#10; * Repository: Maneja la comunicación con el backend para Solicitudes&#10; * Implementa el patrón Repository para separar la lógica de red de la UI&#10; */&#10;class SolicitudRemoteRepository {&#10;&#10;    private val api = RetrofitClient.solicitudApi&#10;&#10;    /**&#10;     * Obtener todas las solicitudes del backend&#10;     */&#10;    suspend fun obtenerSolicitudes(): Result&lt;List&lt;SolicitudDTO&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = api.obtenerSolicitudes()&#10;&#10;                if (response.isSuccessful) {&#10;                    val solicitudes = response.body() ?: emptyList()&#10;                    Result.success(solicitudes)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Error del servidor: ${response.code()} - ${response.message()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SolicitudRemoteRepo&quot;, &quot;Error al obtener solicitudes: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtener una solicitud por ID&#10;     */&#10;    suspend fun obtenerPorId(id: Long): Result&lt;SolicitudDTO&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = api.obtenerPorId(id)&#10;&#10;                if (response.isSuccessful) {&#10;                    val solicitud = response.body()&#10;                    if (solicitud != null) {&#10;                        Result.success(solicitud)&#10;                    } else {&#10;                        Result.failure(Exception(&quot;Solicitud no encontrada&quot;))&#10;                    }&#10;                } else {&#10;                    Result.failure(Exception(&quot;Error: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SolicitudRemoteRepo&quot;, &quot;Error al obtener solicitud: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Crear nueva solicitud en el backend&#10;     */&#10;    suspend fun crearSolicitud(solicitud: SolicitudDTO): Result&lt;SolicitudDTO&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = api.crearSolicitud(solicitud)&#10;&#10;                if (response.isSuccessful) {&#10;                    val solicitudCreada = response.body()&#10;                    if (solicitudCreada != null) {&#10;                        Result.success(solicitudCreada)&#10;                    } else {&#10;                        Result.failure(Exception(&quot;Respuesta vacía del servidor&quot;))&#10;                    }&#10;                } else {&#10;                    Result.failure(Exception(&quot;Error al crear: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SolicitudRemoteRepo&quot;, &quot;Error al crear solicitud: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualizar solicitud existente&#10;     */&#10;    suspend fun actualizarSolicitud(id: Long, solicitud: SolicitudDTO): Result&lt;SolicitudDTO&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = api.actualizarSolicitud(id, solicitud)&#10;&#10;                if (response.isSuccessful) {&#10;                    val actualizada = response.body()&#10;                    if (actualizada != null) {&#10;                        Result.success(actualizada)&#10;                    } else {&#10;                        Result.failure(Exception(&quot;Respuesta vacía&quot;))&#10;                    }&#10;                } else {&#10;                    Result.failure(Exception(&quot;Error al actualizar: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SolicitudRemoteRepo&quot;, &quot;Error al actualizar: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Eliminar solicitud&#10;     */&#10;    suspend fun eliminarSolicitud(id: Long): Result&lt;Unit&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = api.eliminarSolicitud(id)&#10;&#10;                if (response.isSuccessful) {&#10;                    Result.success(Unit)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Error al eliminar: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SolicitudRemoteRepo&quot;, &quot;Error al eliminar: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtener solicitudes por estado&#10;     */&#10;    suspend fun obtenerPorEstado(estado: String): Result&lt;List&lt;SolicitudDTO&gt;&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val response = api.obtenerPorEstado(estado)&#10;&#10;                if (response.isSuccessful) {&#10;                    val solicitudes = response.body() ?: emptyList()&#10;                    Result.success(solicitudes)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Error: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SolicitudRemoteRepo&quot;, &quot;Error al obtener por estado: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/utils/NetworkResult.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/network/utils/NetworkResult.kt" />
              <option name="updatedContent" value="package appserviciotecnico.network.utils&#10;&#10;/**&#10; * Clase sellada para representar los diferentes estados de las operaciones de red&#10; * Permite manejar loading, success y error de forma elegante en la UI&#10; */&#10;sealed class NetworkResult&lt;out T&gt; {&#10;    data class Success&lt;T&gt;(val data: T) : NetworkResult&lt;T&gt;()&#10;    data class Error(val message: String, val exception: Exception? = null) : NetworkResult&lt;Nothing&gt;()&#10;    object Loading : NetworkResult&lt;Nothing&gt;()&#10;    object Idle : NetworkResult&lt;Nothing&gt;()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/ui/screen/SolicitudBackendScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/ui/screen/SolicitudBackendScreen.kt" />
              <option name="updatedContent" value="package appserviciotecnico.ui.screen&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import appserviciotecnico.network.models.SolicitudDTO&#10;import appserviciotecnico.network.utils.NetworkResult&#10;import appserviciotecnico.viewmodel.SolicitudBackendViewModel&#10;&#10;/**&#10; * Pantalla principal para gestionar solicitudes conectadas al backend&#10; * Muestra lista de solicitudes y permite crear, editar y eliminar&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SolicitudBackendScreen(&#10;    viewModel: SolicitudBackendViewModel = viewModel()&#10;) {&#10;    val solicitudesState by viewModel.solicitudesState.collectAsState()&#10;    val crearState by viewModel.crearSolicitudState.collectAsState()&#10;    val eliminarState by viewModel.eliminarState.collectAsState()&#10;&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var solicitudAEditar by remember { mutableStateOf&lt;SolicitudDTO?&gt;(null) }&#10;&#10;    // Cargar solicitudes al inicio&#10;    LaunchedEffect(Unit) {&#10;        viewModel.obtenerSolicitudes()&#10;    }&#10;&#10;    // Mostrar mensaje de éxito al crear&#10;    LaunchedEffect(crearState) {&#10;        if (crearState is NetworkResult.Success) {&#10;            viewModel.resetCrearState()&#10;            showDialog = false&#10;        }&#10;    }&#10;&#10;    // Mostrar mensaje de éxito al eliminar&#10;    LaunchedEffect(eliminarState) {&#10;        if (eliminarState is NetworkResult.Success) {&#10;            viewModel.resetEliminarState()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Gestión de Solicitudes (Backend)&quot;) },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = {&#10;                    solicitudAEditar = null&#10;                    showDialog = true&#10;                }&#10;            ) {&#10;                Icon(Icons.Default.Add, contentDescription = &quot;Crear Solicitud&quot;)&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Indicador de estado&#10;            when (solicitudesState) {&#10;                is NetworkResult.Loading -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                is NetworkResult.Success -&gt; {&#10;                    val solicitudes = (solicitudesState as NetworkResult.Success).data&#10;&#10;                    if (solicitudes.isEmpty()) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                &quot;No hay solicitudes. Crea una nueva.&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    } else {&#10;                        LazyColumn(&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            items(solicitudes) { solicitud -&gt;&#10;                                SolicitudCard(&#10;                                    solicitud = solicitud,&#10;                                    onEdit = {&#10;                                        solicitudAEditar = solicitud&#10;                                        showDialog = true&#10;                                    },&#10;                                    onDelete = {&#10;                                        solicitud.id?.let { viewModel.eliminarSolicitud(it) }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is NetworkResult.Error -&gt; {&#10;                    val error = (solicitudesState as NetworkResult.Error).message&#10;&#10;                    Column(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Text(&#10;                            &quot;Error: $error&quot;,&#10;                            color = MaterialTheme.colorScheme.error,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Button(onClick = { viewModel.obtenerSolicitudes() }) {&#10;                            Text(&quot;Reintentar&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is NetworkResult.Idle -&gt; {&#10;                    // Estado inicial&#10;                }&#10;            }&#10;        }&#10;&#10;        // Diálogo para crear/editar solicitud&#10;        if (showDialog) {&#10;            SolicitudFormDialog(&#10;                solicitud = solicitudAEditar,&#10;                onDismiss = { showDialog = false },&#10;                onSave = { solicitud -&gt;&#10;                    if (solicitudAEditar == null) {&#10;                        viewModel.crearSolicitud(solicitud)&#10;                    } else {&#10;                        solicitud.id?.let { viewModel.actualizarSolicitud(it, solicitud) }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Card para mostrar cada solicitud&#10; */&#10;@Composable&#10;fun SolicitudCard(&#10;    solicitud: SolicitudDTO,&#10;    onEdit: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = solicitud.servicio,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&quot;Cliente: ${solicitud.clienteNombre}&quot;)&#10;            Text(&quot;Fecha: ${solicitud.fechaAgendada} - ${solicitud.horaAgendada}&quot;)&#10;            Text(&quot;Estado: ${solicitud.estado}&quot;)&#10;            Text(&quot;Descripción: ${solicitud.descripcion}&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.End&#10;            ) {&#10;                IconButton(onClick = onEdit) {&#10;                    Icon(Icons.Default.Edit, contentDescription = &quot;Editar&quot;)&#10;                }&#10;                IconButton(onClick = onDelete) {&#10;                    Icon(&#10;                        Icons.Default.Delete,&#10;                        contentDescription = &quot;Eliminar&quot;,&#10;                        tint = MaterialTheme.colorScheme.error&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Diálogo para crear o editar una solicitud&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SolicitudFormDialog(&#10;    solicitud: SolicitudDTO?,&#10;    onDismiss: () -&gt; Unit,&#10;    onSave: (SolicitudDTO) -&gt; Unit&#10;) {&#10;    var servicio by remember { mutableStateOf(solicitud?.servicio ?: &quot;&quot;) }&#10;    var clienteNombre by remember { mutableStateOf(solicitud?.clienteNombre ?: &quot;&quot;) }&#10;    var descripcion by remember { mutableStateOf(solicitud?.descripcion ?: &quot;&quot;) }&#10;    var fechaAgendada by remember { mutableStateOf(solicitud?.fechaAgendada ?: &quot;&quot;) }&#10;    var horaAgendada by remember { mutableStateOf(solicitud?.horaAgendada ?: &quot;&quot;) }&#10;    var estado by remember { mutableStateOf(solicitud?.estado ?: &quot;PENDIENTE&quot;) }&#10;    var categoriaId by remember { mutableStateOf(solicitud?.categoriaId?.toString() ?: &quot;1&quot;) }&#10;&#10;    val estados = listOf(&quot;PENDIENTE&quot;, &quot;EN_PROCESO&quot;, &quot;COMPLETADO&quot;, &quot;CANCELADO&quot;)&#10;    var expandedEstado by remember { mutableStateOf(false) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(if (solicitud == null) &quot;Nueva Solicitud&quot; else &quot;Editar Solicitud&quot;)&#10;        },&#10;        text = {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(8.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = servicio,&#10;                    onValueChange = { servicio = it },&#10;                    label = { Text(&quot;Servicio&quot;) },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                OutlinedTextField(&#10;                    value = clienteNombre,&#10;                    onValueChange = { clienteNombre = it },&#10;                    label = { Text(&quot;Cliente&quot;) },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                OutlinedTextField(&#10;                    value = descripcion,&#10;                    onValueChange = { descripcion = it },&#10;                    label = { Text(&quot;Descripción&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    maxLines = 3&#10;                )&#10;                OutlinedTextField(&#10;                    value = fechaAgendada,&#10;                    onValueChange = { fechaAgendada = it },&#10;                    label = { Text(&quot;Fecha (YYYY-MM-DD)&quot;) },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                OutlinedTextField(&#10;                    value = horaAgendada,&#10;                    onValueChange = { horaAgendada = it },&#10;                    label = { Text(&quot;Hora (HH:mm)&quot;) },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;&#10;                ExposedDropdownMenuBox(&#10;                    expanded = expandedEstado,&#10;                    onExpandedChange = { expandedEstado = !expandedEstado }&#10;                ) {&#10;                    OutlinedTextField(&#10;                        value = estado,&#10;                        onValueChange = {},&#10;                        readOnly = true,&#10;                        label = { Text(&quot;Estado&quot;) },&#10;                        trailingIcon = {&#10;                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedEstado)&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .menuAnchor()&#10;                    )&#10;                    ExposedDropdownMenu(&#10;                        expanded = expandedEstado,&#10;                        onDismissRequest = { expandedEstado = false }&#10;                    ) {&#10;                        estados.forEach { item -&gt;&#10;                            DropdownMenuItem(&#10;                                text = { Text(item) },&#10;                                onClick = {&#10;                                    estado = item&#10;                                    expandedEstado = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                OutlinedTextField(&#10;                    value = categoriaId,&#10;                    onValueChange = { categoriaId = it },&#10;                    label = { Text(&quot;Categoría ID&quot;) },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    val nuevaSolicitud = SolicitudDTO(&#10;                        id = solicitud?.id,&#10;                        servicio = servicio,&#10;                        clienteNombre = clienteNombre,&#10;                        descripcion = descripcion,&#10;                        fechaAgendada = fechaAgendada,&#10;                        horaAgendada = horaAgendada,&#10;                        estado = estado,&#10;                        categoriaId = categoriaId.toIntOrNull() ?: 1&#10;                    )&#10;                    onSave(nuevaSolicitud)&#10;                },&#10;                enabled = servicio.isNotBlank() &amp;&amp; clienteNombre.isNotBlank()&#10;            ) {&#10;                Text(&quot;Guardar&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancelar&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/SolicitudBackendViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/viewmodel/SolicitudBackendViewModel.kt" />
              <option name="updatedContent" value="package appserviciotecnico.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import appserviciotecnico.network.models.SolicitudDTO&#10;import appserviciotecnico.network.repository.SolicitudRemoteRepository&#10;import appserviciotecnico.network.utils.NetworkResult&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * ViewModel: Gestiona el estado de las solicitudes y la comunicación con el backend&#10; * Expone estados reactivos (StateFlow) para que la UI los observe&#10; */&#10;class SolicitudBackendViewModel : ViewModel() {&#10;&#10;    private val repository = SolicitudRemoteRepository()&#10;&#10;    // Estado de la lista de solicitudes&#10;    private val _solicitudesState = MutableStateFlow&lt;NetworkResult&lt;List&lt;SolicitudDTO&gt;&gt;&gt;(NetworkResult.Idle)&#10;    val solicitudesState: StateFlow&lt;NetworkResult&lt;List&lt;SolicitudDTO&gt;&gt;&gt; = _solicitudesState.asStateFlow()&#10;&#10;    // Estado de creación de solicitud&#10;    private val _crearSolicitudState = MutableStateFlow&lt;NetworkResult&lt;SolicitudDTO&gt;&gt;(NetworkResult.Idle)&#10;    val crearSolicitudState: StateFlow&lt;NetworkResult&lt;SolicitudDTO&gt;&gt; = _crearSolicitudState.asStateFlow()&#10;&#10;    // Estado de actualización&#10;    private val _actualizarState = MutableStateFlow&lt;NetworkResult&lt;SolicitudDTO&gt;&gt;(NetworkResult.Idle)&#10;    val actualizarState: StateFlow&lt;NetworkResult&lt;SolicitudDTO&gt;&gt; = _actualizarState.asStateFlow()&#10;&#10;    // Estado de eliminación&#10;    private val _eliminarState = MutableStateFlow&lt;NetworkResult&lt;Unit&gt;&gt;(NetworkResult.Idle)&#10;    val eliminarState: StateFlow&lt;NetworkResult&lt;Unit&gt;&gt; = _eliminarState.asStateFlow()&#10;&#10;    /**&#10;     * Obtener todas las solicitudes del backend&#10;     */&#10;    fun obtenerSolicitudes() {&#10;        viewModelScope.launch {&#10;            _solicitudesState.value = NetworkResult.Loading&#10;&#10;            val result = repository.obtenerSolicitudes()&#10;&#10;            _solicitudesState.value = result.fold(&#10;                onSuccess = { NetworkResult.Success(it) },&#10;                onFailure = { NetworkResult.Error(it.message ?: &quot;Error desconocido&quot;, it as? Exception) }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Crear nueva solicitud&#10;     */&#10;    fun crearSolicitud(solicitud: SolicitudDTO) {&#10;        viewModelScope.launch {&#10;            _crearSolicitudState.value = NetworkResult.Loading&#10;&#10;            val result = repository.crearSolicitud(solicitud)&#10;&#10;            _crearSolicitudState.value = result.fold(&#10;                onSuccess = { NetworkResult.Success(it) },&#10;                onFailure = { NetworkResult.Error(it.message ?: &quot;Error al crear&quot;, it as? Exception) }&#10;            )&#10;&#10;            // Recargar la lista después de crear&#10;            if (result.isSuccess) {&#10;                obtenerSolicitudes()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualizar solicitud existente&#10;     */&#10;    fun actualizarSolicitud(id: Long, solicitud: SolicitudDTO) {&#10;        viewModelScope.launch {&#10;            _actualizarState.value = NetworkResult.Loading&#10;&#10;            val result = repository.actualizarSolicitud(id, solicitud)&#10;&#10;            _actualizarState.value = result.fold(&#10;                onSuccess = { NetworkResult.Success(it) },&#10;                onFailure = { NetworkResult.Error(it.message ?: &quot;Error al actualizar&quot;, it as? Exception) }&#10;            )&#10;&#10;            // Recargar la lista después de actualizar&#10;            if (result.isSuccess) {&#10;                obtenerSolicitudes()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Eliminar solicitud&#10;     */&#10;    fun eliminarSolicitud(id: Long) {&#10;        viewModelScope.launch {&#10;            _eliminarState.value = NetworkResult.Loading&#10;&#10;            val result = repository.eliminarSolicitud(id)&#10;&#10;            _eliminarState.value = result.fold(&#10;                onSuccess = { NetworkResult.Success(Unit) },&#10;                onFailure = { NetworkResult.Error(it.message ?: &quot;Error al eliminar&quot;, it as? Exception) }&#10;            )&#10;&#10;            // Recargar la lista después de eliminar&#10;            if (result.isSuccess) {&#10;                obtenerSolicitudes()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtener solicitudes por estado&#10;     */&#10;    fun obtenerPorEstado(estado: String) {&#10;        viewModelScope.launch {&#10;            _solicitudesState.value = NetworkResult.Loading&#10;&#10;            val result = repository.obtenerPorEstado(estado)&#10;&#10;            _solicitudesState.value = result.fold(&#10;                onSuccess = { NetworkResult.Success(it) },&#10;                onFailure = { NetworkResult.Error(it.message ?: &quot;Error&quot;, it as? Exception) }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetear estados&#10;     */&#10;    fun resetCrearState() {&#10;        _crearSolicitudState.value = NetworkResult.Idle&#10;    }&#10;&#10;    fun resetActualizarState() {&#10;        _actualizarState.value = NetworkResult.Idle&#10;    }&#10;&#10;    fun resetEliminarState() {&#10;        _eliminarState.value = NetworkResult.Idle&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>