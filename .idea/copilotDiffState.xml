<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/ValidadorFormulario.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/ValidadorFormulario.kt" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain&#10;&#10;import appserviciotecnico.model.FormularioServicioErrores&#10;&#10;/**&#10; *  Validador de formularios de servicio técnico&#10; * Centraliza toda la lógica de validación&#10; */&#10;object ValidadorFormulario {&#10;&#10;    /**&#10;     * Valida el campo de correo electrónico&#10;     */&#10;    fun validarCorreo(correo: String): String? {&#10;        return when {&#10;            correo.isBlank() -&gt; &quot;El correo es requerido&quot;&#10;            !correo.contains(&quot;@&quot;) -&gt; &quot;Correo inválido&quot;&#10;            !correo.contains(&quot;.&quot;) -&gt; &quot;Correo inválido&quot;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida el campo de nombre&#10;     */&#10;    fun validarNombre(nombre: String): String? {&#10;        return when {&#10;            nombre.isBlank() -&gt; &quot;El nombre es requerido&quot;&#10;            nombre.length &lt; 3 -&gt; &quot;El nombre debe tener al menos 3 caracteres&quot;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida el campo de teléfono&#10;     */&#10;    fun validarTelefono(telefono: String): String? {&#10;        return when {&#10;            telefono.isBlank() -&gt; &quot;El teléfono es requerido&quot;&#10;            telefono.length &lt; 9 -&gt; &quot;Teléfono inválido&quot;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida el tipo de consola&#10;     */&#10;    fun validarTipoConsola(tipoConsola: String): String? {&#10;        return if (tipoConsola.isBlank()) {&#10;            &quot;Seleccione el tipo de consola&quot;&#10;        } else null&#10;    }&#10;&#10;    /**&#10;     * Valida el modelo de consola&#10;     */&#10;    fun validarModeloConsola(modelo: String): String? {&#10;        return if (modelo.isBlank()) {&#10;            &quot;El modelo es requerido&quot;&#10;        } else null&#10;    }&#10;&#10;    /**&#10;     * Valida la descripción del problema&#10;     */&#10;    fun validarDescripcion(descripcion: String): String? {&#10;        return when {&#10;            descripcion.isBlank() -&gt; &quot;Describa el problema&quot;&#10;            descripcion.length &lt; 10 -&gt; &quot;La descripción debe tener al menos 10 caracteres&quot;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida todos los campos del formulario y retorna los errores&#10;     */&#10;    fun validarFormularioCompleto(&#10;        nombreCliente: String,&#10;        correoCliente: String,&#10;        telefonoCliente: String,&#10;        tipoConsola: String,&#10;        modeloConsola: String,&#10;        descripcionProblema: String&#10;    ): FormularioServicioErrores {&#10;        return FormularioServicioErrores(&#10;            nombreCliente = validarNombre(nombreCliente),&#10;            emailCliente = validarCorreo(correoCliente),&#10;            telefonoCliente = validarTelefono(telefonoCliente),&#10;            tipoConsola = validarTipoConsola(tipoConsola),&#10;            modeloConsola = validarModeloConsola(modeloConsola),&#10;            descripcionProblema = validarDescripcion(descripcionProblema)&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/ValidadorHorario.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/ValidadorHorario.kt" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain&#10;&#10;import java.util.Calendar&#10;&#10;/**&#10; *  Validador de horarios laborales&#10; * Encapsula la lógica de validación de horarios de atención&#10; */&#10;object ValidadorHorario {&#10;&#10;    // Constantes de configuración&#10;    private const val HORA_APERTURA = 10&#10;    private const val HORA_CIERRE = 18&#10;&#10;    /**&#10;     * Valida si una fecha/hora está dentro del horario laboral&#10;     * Horario: Lunes a Sábado, 10:00 - 18:00&#10;     */&#10;    fun validarHorarioLaboral(calendar: Calendar): Boolean {&#10;        val diaSemana = calendar.get(Calendar.DAY_OF_WEEK)&#10;        val hora = calendar.get(Calendar.HOUR_OF_DAY)&#10;        &#10;        // Domingo no es día laboral&#10;        if (diaSemana == Calendar.SUNDAY) {&#10;            return false&#10;        }&#10;        &#10;        // Hora debe estar entre 10:00 y 17:59 (antes de las 18:00)&#10;        return hora in HORA_APERTURA until HORA_CIERRE&#10;    }&#10;&#10;    /**&#10;     * Valida si un día de la semana es laboral&#10;     */&#10;    fun esDiaLaboral(diaSemana: Int): Boolean {&#10;        return diaSemana != Calendar.SUNDAY&#10;    }&#10;&#10;    /**&#10;     * Valida si una hora está dentro del horario de atención&#10;     */&#10;    fun esHoraValida(hora: Int): Boolean {&#10;        return hora in HORA_APERTURA until HORA_CIERRE&#10;    }&#10;&#10;    /**&#10;     * Obtiene mensaje de error según el problema&#10;     */&#10;    fun obtenerMensajeError(calendar: Calendar): String? {&#10;        val diaSemana = calendar.get(Calendar.DAY_OF_WEEK)&#10;        val hora = calendar.get(Calendar.HOUR_OF_DAY)&#10;&#10;        return when {&#10;            diaSemana == Calendar.SUNDAY -&gt; &#10;                &quot;Los domingos no atendemos. Por favor selecciona otro día.&quot;&#10;            hora &lt; HORA_APERTURA -&gt; &#10;                &quot;Nuestro horario de atención comienza a las 10:00 AM&quot;&#10;            hora &gt;= HORA_CIERRE -&gt; &#10;                &quot;Nuestro horario de atención termina a las 6:00 PM&quot;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el horario de atención como texto&#10;     */&#10;    fun obtenerHorarioAtencion(): String {&#10;        return &quot;Lunes a Sábado: $HORA_APERTURA:00 - $HORA_CIERRE:00&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/GuardarSolicitudUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/GuardarSolicitudUseCase.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain.usecases&#10;&#10;import appserviciotecnico.model.entities.SolicitudEntity&#10;import appserviciotecnico.model.repository.SolicitudRepository&#10;&#10;/**&#10; *  Caso de uso: Guardar solicitud de servicio&#10; * Encapsula la lógica de negocio para crear una solicitud&#10; */&#10;class GuardarSolicitudUseCase(&#10;    private val repository: SolicitudRepository&#10;) {&#10;&#10;    suspend fun execute(&#10;        servicioId: Int,&#10;        servicioNombre: String,&#10;        fecha: String,&#10;        hora: String,&#10;        descripcion: String&#10;    ): Result&lt;Long&gt; {&#10;        return try {&#10;            // Validar datos antes de guardar&#10;            if (servicioNombre.isBlank()) {&#10;                return Result.failure(Exception(&quot;El servicio es requerido&quot;))&#10;            }&#10;&#10;            if (fecha.isBlank() || hora.isBlank()) {&#10;                return Result.failure(Exception(&quot;Fecha y hora son requeridas&quot;))&#10;            }&#10;&#10;            // Crear entidad&#10;            val solicitud = SolicitudEntity(&#10;                servicioId = servicioId,&#10;                servicioNombre = servicioNombre,&#10;                fecha = fecha,&#10;                hora = hora,&#10;                estado = &quot;PENDIENTE&quot;,&#10;                descripcion = descripcion,&#10;                clienteNombre = &quot;&quot; // Se puede agregar desde sesión&#10;            )&#10;&#10;            // Guardar en repositorio&#10;            val id = repository.guardarSolicitud(solicitud)&#10;            Result.success(id)&#10;&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/ObtenerSolicitudesUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/appserviciotecnico/model/domain/usecases/ObtenerSolicitudesUseCase.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package appserviciotecnico.model.domain.usecases&#10;&#10;import appserviciotecnico.model.entities.SolicitudEntity&#10;import appserviciotecnico.model.repository.SolicitudRepository&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; *  Caso de uso: Obtener lista de solicitudes&#10; * Encapsula la lógica para recuperar solicitudes del usuario&#10; */&#10;class ObtenerSolicitudesUseCase(&#10;    private val repository: SolicitudRepository&#10;) {&#10;&#10;    /**&#10;     * Obtiene todas las solicitudes como Flow (observables)&#10;     */&#10;    fun execute(): Flow&lt;List&lt;SolicitudEntity&gt;&gt; {&#10;        return repository.obtenerSolicitudes()&#10;    }&#10;&#10;    /**&#10;     * Obtiene solicitudes filtradas por estado&#10;     */&#10;    fun obtenerPorEstado(estado: String): Flow&lt;List&lt;SolicitudEntity&gt;&gt; {&#10;        return repository.obtenerSolicitudesPorEstado(estado)&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/appserviciotecnico/FormularioValidacionTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/appserviciotecnico/FormularioValidacionTest.kt" />
              <option name="originalContent" value="package appserviciotecnico&#10;&#10;import appserviciotecnico.model.FormularioServicioErrores&#10;import appserviciotecnico.viewmodel.FormularioServicioState&#10;import org.junit.Assert.*&#10;import org.junit.Test&#10;&#10;/**&#10; *  Tests unitarios para validaciones del formulario de servicio&#10; */&#10;class FormularioValidacionTest {&#10;&#10;    @Test&#10;    fun test_correo_vacio_es_invalido() {&#10;        // Given (Dado)&#10;        val correoVacio = &quot;&quot;&#10;&#10;        // When (Cuando)&#10;        val esInvalido = correoVacio.isBlank()&#10;&#10;        // Then (Entonces)&#10;        assertTrue(&quot;El correo vacío debe ser inválido&quot;, esInvalido)&#10;    }&#10;&#10;    @Test&#10;    fun test_correo_sin_arroba_es_invalido() {&#10;        // Given&#10;        val correoInvalido = &quot;correosinvalido.com&quot;&#10;&#10;        // When&#10;        val esValido = correoInvalido.contains(&quot;@&quot;)&#10;&#10;        // Then&#10;        assertFalse(&quot;El correo sin @ debe ser inválido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_correo_con_arroba_es_valido() {&#10;        // Given&#10;        val correoValido = &quot;usuario@example.com&quot;&#10;&#10;        // When&#10;        val esValido = correoValido.contains(&quot;@&quot;)&#10;&#10;        // Then&#10;        assertTrue(&quot;El correo con @ debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_nombre_vacio_es_invalido() {&#10;        // Given&#10;        val nombreVacio = &quot;&quot;&#10;&#10;        // When&#10;        val esInvalido = nombreVacio.isBlank()&#10;&#10;        // Then&#10;        assertTrue(&quot;El nombre vacío debe ser inválido&quot;, esInvalido)&#10;    }&#10;&#10;    @Test&#10;    fun test_nombre_con_texto_es_valido() {&#10;        // Given&#10;        val nombreValido = &quot;Juan Pérez&quot;&#10;&#10;        // When&#10;        val esValido = nombreValido.isNotBlank()&#10;&#10;        // Then&#10;        assertTrue(&quot;El nombre con texto debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_telefono_vacio_es_invalido() {&#10;        // Given&#10;        val telefonoVacio = &quot;&quot;&#10;&#10;        // When&#10;        val esInvalido = telefonoVacio.isBlank()&#10;&#10;        // Then&#10;        assertTrue(&quot;El teléfono vacío debe ser inválido&quot;, esInvalido)&#10;    }&#10;&#10;    @Test&#10;    fun test_descripcion_problema_vacio_es_invalido() {&#10;        // Given&#10;        val descripcionVacia = &quot;&quot;&#10;&#10;        // When&#10;        val esInvalido = descripcionVacia.isBlank()&#10;&#10;        // Then&#10;        assertTrue(&quot;La descripción vacía debe ser inválida&quot;, esInvalido)&#10;    }&#10;&#10;    @Test&#10;    fun test_tipo_consola_vacio_es_invalido() {&#10;        // Given&#10;        val tipoConsolaVacio = &quot;&quot;&#10;&#10;        // When&#10;        val esInvalido = tipoConsolaVacio.isBlank()&#10;&#10;        // Then&#10;        assertTrue(&quot;El tipo de consola vacío debe ser inválido&quot;, esInvalido)&#10;    }&#10;&#10;    @Test&#10;    fun test_errores_tiene_metodo_hasErrors() {&#10;        // Given&#10;        val erroresSinErrores = FormularioServicioErrores()&#10;        val erroresConError = FormularioServicioErrores(nombreCliente = &quot;Error de prueba&quot;)&#10;&#10;        // When &amp; Then&#10;        assertFalse(&quot;Sin errores, hasErrors() debe retornar false&quot;, erroresSinErrores.hasErrors())&#10;        assertTrue(&quot;Con errores, hasErrors() debe retornar true&quot;, erroresConError.hasErrors())&#10;    }&#10;&#10;    @Test&#10;    fun test_estado_inicial_esta_vacio() {&#10;        // Given&#10;        val estadoInicial = FormularioServicioState()&#10;&#10;        // Then&#10;        assertTrue(&quot;Nombre inicial debe estar vacío&quot;, estadoInicial.nombreCliente.isEmpty())&#10;        assertTrue(&quot;Correo inicial debe estar vacío&quot;, estadoInicial.correoCliente.isEmpty())&#10;        assertTrue(&quot;Teléfono inicial debe estar vacío&quot;, estadoInicial.telefonoCliente.isEmpty())&#10;        assertTrue(&quot;Tipo consola inicial debe estar vacío&quot;, estadoInicial.tipoConsola.isEmpty())&#10;        assertTrue(&quot;Modelo consola inicial debe estar vacío&quot;, estadoInicial.modeloConsola.isEmpty())&#10;        assertTrue(&quot;Descripción inicial debe estar vacía&quot;, estadoInicial.descripcionProblema.isEmpty())&#10;        assertFalse(&quot;No debe estar enviando inicialmente&quot;, estadoInicial.enviando)&#10;        assertNull(&quot;Mensaje de éxito inicial debe ser null&quot;, estadoInicial.mensajeExito)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package appserviciotecnico&#10;&#10;import appserviciotecnico.model.FormularioServicioErrores&#10;import appserviciotecnico.model.domain.ValidadorFormulario&#10;import appserviciotecnico.viewmodel.FormularioServicioState&#10;import org.junit.Assert.*&#10;import org.junit.Test&#10;&#10;/**&#10; *  Tests unitarios para validaciones del formulario de servicio&#10; * Usa ValidadorFormulario de la capa de dominio&#10; */&#10;class FormularioValidacionTest {&#10;&#10;    @Test&#10;    fun test_correo_vacio_es_invalido() {&#10;        // Given&#10;        val correoVacio = &quot;&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarCorreo(correoVacio)&#10;&#10;        // Then&#10;        assertNotNull(&quot;El correo vacío debe generar error&quot;, error)&#10;        assertEquals(&quot;El correo es requerido&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_correo_sin_arroba_es_invalido() {&#10;        // Given&#10;        val correoInvalido = &quot;correosinvalido.com&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarCorreo(correoInvalido)&#10;&#10;        // Then&#10;        assertNotNull(&quot;El correo sin @ debe generar error&quot;, error)&#10;        assertEquals(&quot;Correo inválido&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_correo_con_arroba_es_valido() {&#10;        // Given&#10;        val correoValido = &quot;usuario@example.com&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarCorreo(correoValido)&#10;&#10;        // Then&#10;        assertNull(&quot;El correo válido no debe generar error&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_nombre_vacio_es_invalido() {&#10;        // Given&#10;        val nombreVacio = &quot;&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarNombre(nombreVacio)&#10;&#10;        // Then&#10;        assertNotNull(&quot;El nombre vacío debe generar error&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_nombre_con_texto_es_valido() {&#10;        // Given&#10;        val nombreValido = &quot;Juan Pérez&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarNombre(nombreValido)&#10;&#10;        // Then&#10;        assertNull(&quot;El nombre válido no debe generar error&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_telefono_vacio_es_invalido() {&#10;        // Given&#10;        val telefonoVacio = &quot;&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarTelefono(telefonoVacio)&#10;&#10;        // Then&#10;        assertNotNull(&quot;El teléfono vacío debe generar error&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_descripcion_problema_vacio_es_invalido() {&#10;        // Given&#10;        val descripcionVacia = &quot;&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarDescripcion(descripcionVacia)&#10;&#10;        // Then&#10;        assertNotNull(&quot;La descripción vacía debe generar error&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_tipo_consola_vacio_es_invalido() {&#10;        // Given&#10;        val tipoConsolaVacio = &quot;&quot;&#10;&#10;        // When&#10;        val error = ValidadorFormulario.validarTipoConsola(tipoConsolaVacio)&#10;&#10;        // Then&#10;        assertNotNull(&quot;El tipo de consola vacío debe generar error&quot;, error)&#10;    }&#10;&#10;    @Test&#10;    fun test_validacion_completa_con_errores() {&#10;        // Given&#10;        val errores = ValidadorFormulario.validarFormularioCompleto(&#10;            nombreCliente = &quot;&quot;,&#10;            correoCliente = &quot;&quot;,&#10;            telefonoCliente = &quot;&quot;,&#10;            tipoConsola = &quot;&quot;,&#10;            modeloConsola = &quot;&quot;,&#10;            descripcionProblema = &quot;&quot;&#10;        )&#10;&#10;        // Then&#10;        assertTrue(&quot;Debe tener errores&quot;, errores.hasErrors())&#10;    }&#10;&#10;    @Test&#10;    fun test_estado_inicial_esta_vacio() {&#10;        // Given&#10;        val estadoInicial = FormularioServicioState()&#10;&#10;        // Then&#10;        assertTrue(&quot;Nombre inicial debe estar vacío&quot;, estadoInicial.nombreCliente.isEmpty())&#10;        assertTrue(&quot;Correo inicial debe estar vacío&quot;, estadoInicial.correoCliente.isEmpty())&#10;        assertTrue(&quot;Teléfono inicial debe estar vacío&quot;, estadoInicial.telefonoCliente.isEmpty())&#10;        assertTrue(&quot;Tipo consola inicial debe estar vacío&quot;, estadoInicial.tipoConsola.isEmpty())&#10;        assertTrue(&quot;Modelo consola inicial debe estar vacío&quot;, estadoInicial.modeloConsola.isEmpty())&#10;        assertTrue(&quot;Descripción inicial debe estar vacía&quot;, estadoInicial.descripcionProblema.isEmpty())&#10;        assertFalse(&quot;No debe estar enviando inicialmente&quot;, estadoInicial.enviando)&#10;        assertNull(&quot;Mensaje de éxito inicial debe ser null&quot;, estadoInicial.mensajeExito)&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/appserviciotecnico/HorarioLaboralTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/appserviciotecnico/HorarioLaboralTest.kt" />
              <option name="originalContent" value="package appserviciotecnico&#10;&#10;import org.junit.Assert.*&#10;import org.junit.Test&#10;import java.util.Calendar&#10;&#10;/**&#10; *  Tests unitarios para validación de horario laboral&#10; * Horario: Lunes a Sábado, 10:00 - 18:00&#10; */&#10;class HorarioLaboralTest {&#10;&#10;    /**&#10;     * Valida si una hora está dentro del horario laboral&#10;     */&#10;    private fun validarHorarioLaboral(calendar: Calendar): Boolean {&#10;        val diaSemana = calendar.get(Calendar.DAY_OF_WEEK)&#10;        val hora = calendar.get(Calendar.HOUR_OF_DAY)&#10;&#10;        // Domingo no es día laboral&#10;        if (diaSemana == Calendar.SUNDAY) {&#10;            return false&#10;        }&#10;&#10;        // Hora debe estar entre 10:00 y 18:00&#10;        return hora in 10..17&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_antes_de_10am_es_invalida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 9)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertFalse(&quot;Hora antes de 10 AM debe ser inválida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_despues_de_6pm_es_invalida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 18)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertFalse(&quot;Hora después de 6 PM debe ser inválida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_domingo_es_invalido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 14)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertFalse(&quot;Domingo debe ser inválido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_lunes_2pm_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 14)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertTrue(&quot;Lunes a las 2 PM debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_sabado_10am_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 10)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertTrue(&quot;Sábado a las 10 AM debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_martes_5pm_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 17) // 5 PM&#10;            set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertTrue(&quot;Martes a las 5 PM debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_viernes_mediodia_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 12)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertTrue(&quot;Viernes al mediodía debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_9am_exacta_es_invalida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 9)&#10;            set(Calendar.MINUTE, 0)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertFalse(&quot;9 AM exacta debe ser inválida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_10am_exacta_es_valida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 10)&#10;            set(Calendar.MINUTE, 0)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertTrue(&quot;10 AM exacta debe ser válida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_sabado_es_dia_laboral() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY)&#10;            set(Calendar.HOUR_OF_DAY, 14)&#10;        }&#10;&#10;        // When&#10;        val esValido = validarHorarioLaboral(calendar)&#10;&#10;        // Then&#10;        assertTrue(&quot;Sábado debe ser día laboral&quot;, esValido)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package appserviciotecnico&#10;&#10;import appserviciotecnico.model.domain.ValidadorHorario&#10;import org.junit.Assert.*&#10;import org.junit.Test&#10;import java.util.Calendar&#10;&#10;/**&#10; *  Tests unitarios para validación de horario laboral&#10; * Usa ValidadorHorario de la capa de dominio&#10; * Horario: Lunes a Sábado, 10:00 - 18:00&#10; */&#10;class HorarioLaboralTest {&#10;&#10;    @Test&#10;    fun test_hora_antes_de_10am_es_invalida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 9)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertFalse(&quot;Hora antes de 10 AM debe ser inválida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_despues_de_6pm_es_invalida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 18)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertFalse(&quot;Hora después de 6 PM debe ser inválida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_domingo_es_invalido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 14)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        val esDiaLaboral = ValidadorHorario.esDiaLaboral(Calendar.SUNDAY)&#10;        &#10;        // Then&#10;        assertFalse(&quot;Domingo debe ser inválido&quot;, esValido)&#10;        assertFalse(&quot;Domingo no debe ser día laboral&quot;, esDiaLaboral)&#10;    }&#10;&#10;    @Test&#10;    fun test_lunes_2pm_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 14)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertTrue(&quot;Lunes a las 2 PM debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_sabado_10am_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 10)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertTrue(&quot;Sábado a las 10 AM debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_martes_5pm_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 17) // 5 PM&#10;            set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertTrue(&quot;Martes a las 5 PM debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_viernes_mediodia_es_valido() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 12)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertTrue(&quot;Viernes al mediodía debe ser válido&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_9am_exacta_es_invalida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 9)&#10;            set(Calendar.MINUTE, 0)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        val mensajeError = ValidadorHorario.obtenerMensajeError(calendar)&#10;        &#10;        // Then&#10;        assertFalse(&quot;9 AM exacta debe ser inválida&quot;, esValido)&#10;        assertNotNull(&quot;Debe haber mensaje de error&quot;, mensajeError)&#10;    }&#10;&#10;    @Test&#10;    fun test_hora_10am_exacta_es_valida() {&#10;        // Given&#10;        val calendar = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, 10)&#10;            set(Calendar.MINUTE, 0)&#10;            set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY)&#10;        }&#10;        &#10;        // When&#10;        val esValido = ValidadorHorario.validarHorarioLaboral(calendar)&#10;        &#10;        // Then&#10;        assertTrue(&quot;10 AM exacta debe ser válida&quot;, esValido)&#10;    }&#10;&#10;    @Test&#10;    fun test_sabado_es_dia_laboral() {&#10;        // Given &amp; When&#10;        val esDiaLaboral = ValidadorHorario.esDiaLaboral(Calendar.SATURDAY)&#10;        &#10;        // Then&#10;        assertTrue(&quot;Sábado debe ser día laboral&quot;, esDiaLaboral)&#10;    }&#10;&#10;    @Test&#10;    fun test_obtener_horario_atencion() {&#10;        // When&#10;        val horario = ValidadorHorario.obtenerHorarioAtencion()&#10;        &#10;        // Then&#10;        assertNotNull(&quot;Debe retornar horario de atención&quot;, horario)&#10;        assertTrue(&quot;Debe contener información de horario&quot;, horario.contains(&quot;10:00&quot;))&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>